#pragma once
#include <utility/diagnostics/error.h>
#include <utility/containers/long_string.h>

#include "intermediate_representation/nodes/function.h"
#include "intermediate_representation/code_generation/targets/target_base.h"

// The entire IR system is based off of an implementation in Cuik's Tilde backend
// (https://github.com/RealNeGate/Cuik/tree/master/tb)

// Root code generation file, contains the main module structure. Each module
// contains a list of functions, and every function contains an allocator through
// which it allocates and stores nodes, which represent the operation tree of the
// given function. 

namespace ir {
	enum class arch {
		x64 // x86/x64
	};

	enum class system {
		windows,
		linux,
		mac_os,
		android,
		web
	};

	enum class abi {
		win64,   // 64 bit windows
		system_v // mac, bsd, and linux
	};

	// general memory model:
	// every function keeps its own block of memory, which is currently allocated
	// in a linear, and unaligned fashion.
	// todo: implement a more performant, aligned memory allocator 

	/**
	 * \brief Basic builder which serves as a facade around the process of
	 * constructing proper IR.
	 */
	class module {
	public:
		/**
		 * \brief Compiles the module for the specified target.
		 * \param arch Target arch
		 * \param system Target system
		 * \return Outcome (buffer containing the generated bytecode).
		 */
		utility::outcome::result<s_ptr<cg::code_generation_result>> compile(
			arch arch, system system
		);

		/**
		 * \brief Emits the underlying graph in the graphviz 'dot' format.
		 * \param string String used to store the generated .dot file
		 */
		void print_node_graph(
			utility::long_string& string
		) const;

		/**
		 * \brief Creates a new function.
		 * \param identifier Unique identifier of the function
		 * \param returns List of returns the function manages
		 * \return Handle to the generated function object.
		 */
		handle<function> create_function(
			const std::string& identifier, const std::vector<data_type>& returns
		);

		/**
		 * \brief Creates a new signed integer immediate.
		 * \param value Value of the signed integer
		 * \param bit_width Bit width of the integer
		 * \return Handle to the relevant integer node.
		 */
		handle<node> create_signed_integer(i64 value, u8 bit_width);

		/**
		 * \brief Creates a new local (variable)
		 * \param size Size of the variable (bytes)
		 * \param alignment Alignment of the variable (bytes) (must be a multiple of 2)
		 * \return Handle to the relevant node.
		 */
		handle<node> create_local(
			u32 size, u32 alignment
		);

		/**
		 * \brief Creates a new function return. 
		 * \param values List of values that should be returned
		 */
		void create_ret(const std::vector<handle<node>>& virtual_values);

		/**
		 * \brief Creates a new goto.
		 * \param target Target the goto should jump to
		 */
		void create_goto(handle<node> target);

		/**
		 * \brief Creates a new store operation.
		 * \param destination Destination \a val should be stored at
		 * \param value Value to store
		 * \param alignment Alignment of the store operand in bytes
		 * \param is_volatile Whether the store operation is volatile (volatile stores will be interpreted as writes)
		 */
		void create_store(
			handle<node> destination, handle<node> value, u32 alignment,
			bool is_volatile
		);

		/**
		 * \brief Creates a new add operation.
		 * \param left Left operand
		 * \param right Right operand
		 * \param behaviour Arithmetic behaviour of the operation
		 * \return Handle to the node containing the operation result
		 */
		handle<node> create_add(
			handle<node> left, handle<node> right,
			arithmetic_behaviour behaviour = arithmetic_behaviour::none
		);

		/**
		 * \brief Creates a new sub operation.
		 * \param left Left operand
		 * \param right Right operand
		 * \param behaviour Arithmetic behaviour of the operation
		 * \return Handle to the node containing the operation result
		 */
		handle<node> create_sub(
			handle<node> left, handle<node> right,
			arithmetic_behaviour behaviour = arithmetic_behaviour::none
		);
	private:
		std::vector<handle<node>>& add_successors(
			handle<node> terminator, u64 count
		) const;

		handle<node> create_binary_arithmetic_operation(
			node::type type, handle<node> left, handle<node> right,
			arithmetic_behaviour behaviour
		);

		handle<node> create_projection(data_type dt, handle<node> src, i32 index);
		static handle<node> peek_memory(handle<node> control);
		handle<node> append_memory(handle<node> new_mem) const;

		template<typename extra_type = empty_property>
		handle<node> create_node(node::type type, u64 input_count);
	private:
		std::vector<function> m_functions;
	};

	template<typename extra_type>
	handle<node> module::create_node(node::type type, u64 input_count) {
		ASSERT(!m_functions.empty(), "no valid function to use found");
		const handle<node> node = m_functions.back().allocate_node<extra_type>(type, input_count);
		return node;
	}
}
