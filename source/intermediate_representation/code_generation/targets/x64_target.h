#pragma once
#include "intermediate_representation/code_generation/targets/target_base.h"
#include "intermediate_representation/code_generation/instruction.h"
#include "intermediate_representation/code_generation/live_interval.h"
#include "intermediate_representation/code_generation/targets/x64/registers.h"

#define INSTRUCTION_COUNT 120

namespace ir::cg {
	enum x64_data_type {
		none = 0,

		byte,
		word,
		dword,
		qword,

		pbyte,
		pword,
		pdword,
		pqword,

		sse_ss,
		sse_sd,
		sse_ps,
		sse_pd,

		xmmword
	};

	enum mod : u8 {
		indirect                 = 0, // [rax]
		indirect_displacement_8  = 1, // [rax + disp8]
		indirect_displacement_32 = 2, // [rax + disp32]
		direct                   = 3, // rax
	};

	struct abs_prop {
		u64 value;
	};

	struct target_prop {
		handle<node> target;
	};

	class value : public utility::property<abs_prop, target_prop> {
	public:
		enum type {
			none,
			flags,
			gpr,
			xmm,
			imm,
			mem,
			global,
			abs,
			label
		};

		static handle<value> create_label(handle<node> target);
		static handle<value> create_imm(i32 imm);

		type get_type() const;
		u8 get_reg() const;
		u8 get_index() const;
		i32 get_imm() const;
		scale get_scale() const;

		void set_type(type type);
		void set_reg(u8 reg);
		void set_index(u8 index);
		void set_scale(scale scale);
		void set_imm(i32 imm);

		template<typename property>
		static handle<value> create_value() {
			void* allocation = s_value_allocator.allocate(sizeof(value));
			const handle value_ptr = static_cast<value*>(allocation);

			// assign data
			value_ptr->m_property = s_value_allocator.allocate(sizeof(property));
			return value_ptr;
		}

		bool matches(handle<value> b) const;
	private:
		type m_type;
		u8 m_reg;
		u8 m_index;
		scale m_scale;
		i32 m_imm;
		static utility::block_allocator s_value_allocator;
	};

	// TODO: handle this a bit more nicely
	std::array<instruction::description, INSTRUCTION_COUNT> initialize_x64_instruction_table();
	const auto g_x64_instruction_table = initialize_x64_instruction_table();

	class x64_target : public target_base {
	public:
		/**
		 * \brief Emits bytecode into the given \a buffer for the given the x64 win
		 * platform.
		 * \param context Code generation context
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_code(
			code_generator_context& context,
			s_ptr<cg::code_generation_result> result
		) override;

		void allocate_base_registers(
			code_generator_context& context
		) override;

		i32 legalize_data_type(const data_type& data_type) override;
		u8 classify_register_class(const data_type& data_type) override;
	private:
		/**
		 * \brief Emits the function prologue (sets up the stack frame and
		 * allocates space for local variables).
		 * \param context Code generation context
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_prologue(
			code_generator_context& context,
			utility::byte_buffer& bytecode
		);

		/**
		 * \brief Emits the function body for the given context.
		 * \param context Code generation context
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_function_body(
			code_generator_context& context,
			utility::byte_buffer& bytecode
		);

		/**
		 * \brief Emits the function epilogue (frees the allocated stack space and
		 * sets up a return statement).
		 * \param context Code generation context
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_epilogue(
			code_generator_context& context,
			utility::byte_buffer& bytecode
		);

		/**
		 * \brief Emits a single x64 instruction with no operands.
		 * \param type Instruction type to emit
		 * \param data_type x64 data type for the instruction
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		static void emit_instruction_0(
			instruction::type type, i32 data_type, utility::byte_buffer& bytecode
		);

		/**
		 * \brief Emits and prints a single x64 instruction with one operand.
		 * \param type Instruction type to emit
		 * \param src Handle to the source operand for the instruction
		 * \param data_type x64 data type for the instruction
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_instruction_1_print(
			code_generator_context& context,
			instruction::type type, 
			handle<value> src,
			i32 data_type, 
			utility::byte_buffer& bytecode
		);

		void emit_instruction_1(
			code_generator_context& context,
			instruction::type type,
			handle<value> r,
			i32 dt,
			utility::byte_buffer& bytecode
		);

		/**
		 * \brief Emits and prints a single x64 instruction with two operands.
		 * \param type Instruction type to emit
		 * \param dst Handle to the destination operand for the instruction
		 * \param src Handle to the source operand for the instruction
		 * \param data_type x64 data type for the instruction
		 * \param buffer Buffer used for storing the generated bytecode
		 */
		void emit_instruction_2_print(
			instruction::type type,
			handle<value> dst,
			handle<value> src,
			i32 data_type,
			utility::byte_buffer& bytecode
		);

		void emit_instruction_2(
			instruction::type type,
			handle<value> a,
			handle<value> b,
			i32 dt,
			utility::byte_buffer& bytecode
		);

		void emit_memory_operand(
			u8 rx, handle<value> a, utility::byte_buffer& bytecode
		);

		/**
		 * \brief Prints the given operand as a string.
		 * \param val Value to print
		 * \param data_type Data type used for interpreting the given value
		 */
		void print_operand(
			handle<value> val, i32 data_type
		);

		/**
		 * \brief Resolves the given instruction interval (handles registers,
		 * memory, etc.).
		 * \param context Code generation context
		 * \param inst Instruction to resolve
		 * \param i Instruction operand slot
		 * \param val Value to resolve for
		 * \return Resolved base
		 */
		static i32 resolve_interval(
			code_generator_context& context,
			handle<instruction> inst,
			i32 i,
			handle<value> val
		);

		/**
		 * \brief Computes the REX (register extension) prefix for byte for an x64
		 * instruction.
		 * \param is_64bit Flag indicating whether the instruction operates
		 * in 64-bit mode
		 * \param rx Register extension field for the destination operand
		 * \param base Register extension field for the base register in
		 * memory addressing
		 * \param index Register extension field for the index register in
		 * memory addressing
		 * \return Computed REX prefix byte.
		 * \details The REX prefix byte has the following structure:
		 * - Bit 7: Fixed at 1 to indicate this is a REX prefix.
		 * - Bit 6: REX.W bit, set if the instruction operates in 64-bit mode.
		 * - Bit 5: REX.R bit, extension of the ModR/M reg field.
		 * - Bit 4: REX.X bit, extension of the SIB index field.
		 * - Bit 3: REX.B bit, extension of the ModR/M r/m field, SIB base field, or opcode reg field.
		 * - Bits 2-0: Fixed at 0.
		 */
		static u8 rex(bool is_64bit, u8 rx, u8 base, u8 index);

		/**
		 * \brief Computes the ModR/M byte for an x64 instruction.
		 * \param mod Mode specifying the addressing mode and register/memory type
		 * \param rx Register extension field, typically used to specify the
		 * destination operand
		 * \param rm Register/memory field, used to specify source operand or
		 * base register in memory addressing
		 * \return Returns the computed ModR/M byte.
		 * \details The ModR/M byte has the following structure:
		 * - Bits 7-6: Mod field, used to specify addressing mode and register/memory type.
		 * - Bits 5-3: Reg/Opcode field (referred to here as 'rx'), used to specify destination operand or extend opcode.
		 * - Bits 2-0: R/M field, used to specify source operand or memory addressing mode.
		 */
		static u8 mod_rx_rm(mod mod, u8 rx, u8 rm);

		template<typename ...arguments>
		void emit_assembly(
			const std::format_string<arguments...> fmt,
			arguments&& ...args
		) {
			if (m_assembly_output) {
				m_assembly_output->append(fmt, std::forward<arguments>(args)...);
			}
		}

		static x64_data_type legalize_integer_data_type(u64* out_mask, const data_type& data_type);

	private:
		utility::long_string* m_assembly_output;
	};
}

